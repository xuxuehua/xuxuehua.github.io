<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>special_characters - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#Linux">Linux</a>&nbsp;&#187;&nbsp;special_characters
    <span class="updated">Page Updated&nbsp;
      2019-04-17 16:05
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">special_characters</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">特殊符号</a></li>
</ul>
</div>
<h1 id="_1">特殊符号</h1>
<div class="hlcode"><pre><span class="s-Atom">在shell中常用的特殊符号罗列如下：</span> 

<span class="s-Atom">#</span> <span class="p">;</span>   <span class="p">;;</span> <span class="p">.</span> <span class="p">,</span> <span class="o">/</span> <span class="s-Atom">\\</span> <span class="s-Atom">&#39;string&#39;</span><span class="p">|</span> <span class="p">!</span>   <span class="err">$</span>   <span class="err">$</span><span class="p">{}</span>   <span class="err">$</span><span class="s-Atom">?</span> <span class="err">$$</span>   <span class="err">$</span><span class="o">*</span> 

<span class="s-Atom">\</span><span class="s2">&quot;string\&quot;* **   ? : ^ $#   $@ `command`{}   [] [[]] ()   (()) </span>

<span class="s2">||   &amp;&amp; {xx,yy,zz,...}~   ~+   ~-   &amp;   \\&lt;...\\&gt;   + - %=   ==   != </span>


<span class="s2"># 井号 (comments) </span>
<span class="s2">这几乎是个满场都有的符号，除了先前已经提过的\&quot;第一行\&quot; </span>
<span class="s2">#!/bin/bash </span>
<span class="s2">井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。 </span>
<span class="s2"># This line is comments. </span>
<span class="s2">echo \&quot;a = $a\&quot; # a = 0 </span>
<span class="s2">由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。 </span>
<span class="s2">#echo \&quot;a = $a\&quot; # a = 0 </span>
<span class="s2">如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。 </span>


<span class="s2">~ 帐户的 home 目录 </span>
<span class="s2">算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin </span>
<span class="s2">~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。 </span>
<span class="s2"># echo ~+/var/log </span>
<span class="s2">~- 上次的工作目录，这个符号代表上次的工作目录。 </span>
<span class="s2"># echo ~-/etc/httpd/logs </span>


<span class="s2">; 分号 (Command separator) </span>
<span class="s2">在 shell 中，担任\&quot;连续指令\&quot;功能的符号就是\&quot;分号\&quot;。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/. </span>


<span class="s2">;; 连续分号 (Terminator) </span>
<span class="s2">专用在 case 的选项，担任 Terminator 的角色。 </span>
<span class="s2">case \&quot;$fop\&quot; inhelp) echo \&quot;Usage: Command -help -version filename\&quot;;;version) echo \&quot;version 0.1\&quot; ;;esac </span>


<span class="s2">. 逗号 (dot,就是“点”) </span>
<span class="s2">在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。 </span>
<span class="s2">CDPATH=.:~:/home:/home/web:/var:/usr/local </span>
<span class="s2">在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。 </span>
<span class="s2">如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。 </span>


<span class="s2">&#39;string&#39; 单引号 (single quote) </span>
<span class="s2">被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。 </span>
<span class="s2">heyyou=homeecho &#39;$heyyou&#39; # We get $heyyou </span>


<span class="s2">\&quot;string\&quot; 双引号 (double quote) </span>
<span class="s2">被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。 </span>
<span class="s2">heyyou=homeecho \&quot;$heyyou\&quot; # We get home </span>

<span class="s2">`command` 倒引号 (backticks) </span>
<span class="s2">在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。 </span>
<span class="s2">fdv=`date +%F`echo \&quot;Today $fdv\&quot; </span>
<span class="s2">在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。 </span>


<span class="s2">, 逗点 (comma，标点中的逗号) </span>
<span class="s2">这个符号常运用在运算当中当做\&quot;区隔\&quot;用途。如下例 </span>
<span class="s2">#!/bin/bashlet \&quot;t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\&quot;echo \&quot;t1= $t1, a = $a, b = $b\&quot; </span>


<span class="s2">/ 斜线 (forward slash) </span>
<span class="s2">在路径表示时，代表目录。 </span>
<span class="s2">cd /etc/rc.dcd ../..cd / </span>
<span class="s2">通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。 </span>
<span class="s2">let \&quot;num1 = ((a = 10 / 2, b = 25 / 5))\&quot; </span>


<span class="s2">\\ 倒斜线 </span>
<span class="s2">在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。 </span>
<span class="s2"># type rmrm is aliased to `rm -i&#39;# \\rm ./*.log </span>
<span class="s2">上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。 </span>
<span class="s2"># bkdir=/home# echo \&quot;Backup dir, \\$bkdir = $bkdir\&quot;Backup dir,$bkdir = /home </span>
<span class="s2">上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。 </span>


<span class="s2">| 管道 (pipeline) </span>
<span class="s2">pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。 </span>
<span class="s2">who | wc -l </span>
<span class="s2">善用这个观念，对精简 script 有相当的帮助。 </span>


<span class="s2">! 惊叹号(negate or reverse) </span>
<span class="s2">通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表\&quot;不等于\&quot; </span>
<span class="s2">if [ \&quot;$?\&quot; != 0 ]thenecho \&quot;Executes error\&quot;exit 1fi </span>
<span class="s2">在规则表达式中她担任 \&quot;反逻辑\&quot; 的角色 </span>
<span class="s2">ls a[!0-9] </span>
<span class="s2">上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。 </span>


<span class="s2">: 冒号 </span>
<span class="s2">在 bash 中，这是一个内建指令：\&quot;什么事都不干\&quot;，但返回状态值 0。 </span>
<span class="s2">: </span>
<span class="s2">echo $? # 回应为 0 </span>
<span class="s2">: &gt; f.$$ </span>
<span class="s2">上面这一行，相当于 cat /dev/null &gt;f.$$。不仅写法简短了，而且执行效率也好上许多。 </span>
<span class="s2">有时，也会出现以下这类的用法 </span>
<span class="s2">: ${HOSTNAME?} ${USER?} ${MAIL?} </span>
<span class="s2">这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。 </span>


<span class="s2">? 问号 (wild card) </span>
<span class="s2">在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。 </span>
<span class="s2"># ls a?a1 </span>
<span class="s2">善用她的特点，可以做比较精确的档名匹配。 </span>


<span class="s2">* 星号 (wild card) </span>
<span class="s2">相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。 </span>
<span class="s2"># ls a*a a1 access_log </span>
<span class="s2">在运算时，它则代表 \&quot;乘法\&quot;。 </span>
<span class="s2">let \&quot;fmult=2*3\&quot; </span>
<span class="s2">除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任\&quot;乘法\&quot;的角色。不过在使用上得小心，他的前面必须加上escape 字元。 </span>


<span class="s2">** 次方运算 </span>
<span class="s2">两个星号在运算时代表 \&quot;次方\&quot; 的意思。 </span>
<span class="s2">let \&quot;sus=2**3\&quot;echo \&quot;sus = $sus\&quot; # sus = 8 </span>


<span class="s2">$ 钱号(dollar sign) </span>
<span class="s2">变量替换(Variable Substitution)的代表符号。 </span>
<span class="s2">vrs=123echo \&quot;vrs = $vrs\&quot; # vrs = 123 </span>
<span class="s2">另外，在 Regular Expressions 里被定义为 \&quot;行\&quot; 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中。 </span>


<span class="s2">${} 变量的正规表达式 </span>
<span class="s2">bash 对 ${} 定义了不少用法。以下是取自线上说明的表列 </span>
<span class="s2">   ${parameter:-word}   ${parameter:=word}   ${parameter:?word}   ${parameter:+word}   ${parameterffset}   ${parameterffset:length}   ${!prefix*}   ${#parameter}   ${parameter#word}   ${parameter##word}   ${parameter%word}   ${parameter%%word}   ${parameter/pattern/string}   ${parameter//pattern/string} </span>


<span class="s2">$* </span>
<span class="s2">$* 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下： </span>
<span class="s2">$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}..... </span>
<span class="s2">个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。 </span>
<span class="s2">$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。 </span>
<span class="s2">echo \&quot;$*\&quot; </span>
<span class="s2">还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。 </span>


<span class="s2">$@ </span>
<span class="s2">$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。 </span>
<span class="s2">符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。 </span>

<span class="s2">$# </span>
<span class="s2">这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。 </span>
<span class="s2">echo \&quot;$#\&quot; </span>


<span class="s2">$? 状态值 (status variable) </span>
<span class="s2">一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。 </span>
<span class="s2">一般指令程序倘若执行成功，其回传值为 0；失败为 1。 </span>
<span class="s2">tar cvfz dfbackup.tar.gz /home/user &gt; /dev/nullecho\&quot;$?\&quot;$$ </span>
<span class="s2">由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号$$或许可以符合这种需求。它代表当前shell 的 PID。 </span>
<span class="s2">echo \&quot;$HOSTNAME, $USER, $MAIL\&quot; &gt; ftmp.$$ </span>
<span class="s2">使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。 </span>
<span class="s2">ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。 </span>

<span class="s2">(   ) 指令群组 (command group) </span>
<span class="s2">用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子 </span>
<span class="s2"># cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e \&quot;\\n $a \\n\&quot;)echo $a#./ftmp-01incgfsh </span>
<span class="s2">除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。 </span>


<span class="s2">(( )) </span>
<span class="s2">这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。 </span>
<span class="s2">#!/bin/bash(( a = 10 ))echo -e \&quot;inital value, a = $a\\n\&quot;(( a++))echo \&quot;after a++, a = $a\&quot; </span>

<span class="s2">{ } 大括号 (Block of code) </span>
<span class="s2">有时候 script 当中会出现，大括号中会夹着一段或几段以\&quot;分号\&quot;做结尾的指令或变数设定。 </span>
<span class="s2"># cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e \&quot;\\n $a \\n\&quot;}echo $a#./ftmp-02inbcinbc </span>
<span class="s2">这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。 </span>
<span class="s2">大括号也被运用在 \&quot;函数\&quot; 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。 </span>

<span class="s2">此外，大括号还有另一种用法，如下 </span>
<span class="s2">{xx,yy,zz,...} </span>
<span class="s2">这种大括号的组合，常用在字串的组合上，来看个例子 </span>
<span class="s2">mkdir {userA,userB,userC}-{home,bin,data} </span>
<span class="s2">我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子 </span>
<span class="s2">chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}} </span>
<span class="s2">如果不是因为支援这种用法，我们得写几行重复几次呀！ </span>


<span class="s2">[   ] 中括号 </span>
<span class="s2">常出现在流程控制中，扮演括住判断式的作用。if [ \&quot;$?\&quot; != 0 ]thenecho \&quot;Executes error\&quot;exit1fi </span>
<span class="s2">这个符号在正则表达式中担任类似 \&quot;范围\&quot; 或 \&quot;集合\&quot; 的角色 </span>
<span class="s2">rm -r 200[1234] </span>
<span class="s2">上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。 </span>


<span class="s2">[[ ]] </span>
<span class="s2">这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&amp;&amp; 逻辑等符号。 </span>
<span class="s2">#!/bin/bashread akif [[ $ak &gt; 5 || $ak&lt; 9 ]]thenecho $akfi </span>


<span class="s2">|| 逻辑符号 </span>
<span class="s2">这个会时常看到，代表 or 逻辑的符号。 </span>


<span class="s2">&amp;&amp; 逻辑符号 </span>
<span class="s2">这个也会常看到，代表 and 逻辑的符号。 </span>


<span class="s2">&amp; 后台工作 </span>
<span class="s2">单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 </span>
<span class="s2">tar cvfz data.tar.gz data &gt; /dev/null&amp; </span>

<span class="s2">\\&lt;...\\&gt; 单字边界 </span>
<span class="s2">这组符号在规则表达式中，被定义为\&quot;边界\&quot;的意思。譬如，当我们想找寻 the 这个单字时，如果我们用 </span>
<span class="s2">grep the FileA </span>
<span class="s2">你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 \&quot;边界\&quot; 的符号 </span>
<span class="s2">grep &#39;\\&#39; FileA </span>


<span class="s2">+ 加号 (plus) </span>
<span class="s2">在运算式中，她用来表示 \&quot;加法\&quot;。 </span>
<span class="s2">expr 1 + 2 + 3 </span>
<span class="s2">此外在规则表达式中，用来表示\&quot;很多个\&quot;的前面字元的意思。 </span>
<span class="s2"># grep &#39;10\\+9&#39; fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。 </span>


<span class="s2">- 减号 (dash) </span>
<span class="s2">在运算式中，她用来表示 \&quot;减法\&quot;。 </span>
<span class="s2">expr 10 - 2 </span>
<span class="s2">此外也是系统指令的选项符号。 </span>
<span class="s2">ls -expr 10 - 2 </span>
<span class="s2">在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表\&quot;标准输入\&quot;的意思。这是 GNU指令的共通选项。譬如下例 </span>
<span class="s2">tar xpvf - </span>
<span class="s2">这里的 - 符号，既代表从标准输入读取资料。 </span>
<span class="s2">不过，在 cd 指令中则比较特别 </span>
<span class="s2">cd - </span>
<span class="s2">这代表变更工作目录到\&quot;上一次\&quot;工作目录。 </span>


<span class="s2">% 除法 (Modulo) </span>
<span class="s2">在运算式中，用来表示 \&quot;除法\&quot;。 </span>
<span class="s2">expr 10 % 2 </span>
<span class="s2">此外，也被运用在关于变量的规则表达式当中的下列 </span>
<span class="s2">${parameter%word}${parameter%%word} </span>
<span class="s2">一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。 </span>


<span class="s2">= 等号 (Equals) </span>
<span class="s2">常在设定变数时看到的符号。 </span>
<span class="s2">vara=123echo \&quot; vara = $vara\&quot; </span>
<span class="s2">或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。 </span>


<span class="s2">== 等号 (Equals) </span>
<span class="s2">常在条件判断式中看到，代表 \&quot;等于\&quot; 的意思。 </span>
<span class="s2">if [ $vara == $varb ] </span>
<span class="s2">...下略 </span>

<span class="s2">!= 不等于 </span>
<span class="s2">常在条件判断式中看到，代表 \&quot;不等于\&quot; 的意思。 </span>
<span class="s2">if [ $vara != $varb ] </span>
<span class="s2">...下略 </span>


<span class="s2">^ </span>
<span class="s2">这个符号在规则表达式中，代表行的 \&quot;开头\&quot; 位置，在[]中也与\&quot;!\&quot;</span><span class="p">(</span><span class="s-Atom">叹号</span><span class="p">)</span><span class="s-Atom">一样表示“非”</span> 
</pre></div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-05-24 01:26:43</p>
      </span>
    </div>

    
    
  </body>
</html>